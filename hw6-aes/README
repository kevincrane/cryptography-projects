Kevin Crane
ID#: 3218-2771-59
CSCI-531 
Homework 5 - DES (Data Encryption Standard)

1. Use
	- Compile with:
		make hw5
	- Check the integrity of tablefile
		./hw5 tablecheck -t=tablefile
	- Encrypts the input using DES driven by tablefile in the ECB mode using key as the encryption key
		./hw5 encrypt -k=key -t=tablefile [file]
	- Decrypts the input using DES driven by tablefile in the ECB mode using key as the encryption key
		./hw5 decrypt -k=key -t=tablefile [file]
	- Encrypts the input using EDE triple DES driven by tablefile in the ECB mode using key3 as the encryption key
		./hw5 encrypt3 -k=key3 -t=tablefile [file]
	- Decrypts the input using EDE triple DES driven by tablefile in the ECB mode using key3 as the encryption key
		./hw5 decrypt3 -k=key3 -t=tablefile [file]
	- Clean binary files with:
		make clean

2. Design
	- Tablecheck
		- Use read_line_vals method to search through file until finds a line starting with header
		- Read each item in the line into an array of ints, using comma delimiters to separate
		- Run whatever test is needed on the array to ensure that all the values are valid
			- Usually something like counting the instances of each number to ensure correct permutation
		- Repeat for all headers
	- Encrypt
		- Key Generation
			- The user inputs a 8 byte key as 16 hex characters
			- First, this key must be converted from a 16-byte string to an 8-byte string
			  by parsing the hex characters
			- Next, the tablefile is read and the rows for V, PC1, and PC2 are stored in arrays
			- The initial C and D values are generated by removing the parity bits
			  (every bit divisible by 8) and permutating the remaining bits against PC1 values.
			- For each of the 16 rounds:
				- Circular shift C and D values by 1 or 2 spaces, dictated by V values
				- Take these new values, concatanate them, and permutate based on PC2 values
				- Store this round's key and repeat
			- Should now have array with 16 48-bit keys (6-bytes each).
		- Break original input into multiple 8-byte blocks
		- Encryption (perform for each 8-byte block)
			- Perform the Initial Permutation function, split into 2 32-bit halves (L0 and R0)
			- Repeat the following steps for 16 rounds:
			- L(i) = R(i-1)
			- Expansion (performed on half R(i-1))
				- Using the E values in the table, expand the original 32-bit value to 48-bits
			- XOR this 48-bit value with 48-bit k(i)
			- Substitution
				- Using the 8 S# values in the tablefile:
				- Split the 48-bit block into 8 6-bit blocks
				- Read the values from the tablefile to convert each 6-bit block to 4-bits
				- This should leave you with 8 4-bit blocks (32-bit value)
			- Permutation
				- Use P values from tablefile to permute the R(i-1) values
			- XOR R(i-1) with L(i-1), set the result to R(i)
			- Repeat this 16 times, except not swapping sides on round 16
			- Perform the Inverse Initial Permutation on the final output
		- Print the 8-byte output from above, repeat until input complete
	- Decrypt
		- Generate 16 round keys
		- Read file input in 8-byte blocks
		- Perform the same operations as encryption
			- Only difference, before each round, reverse the order of the keys
		- Print each block output
		- Repeat
	- Encrypt3
		- Break original key in thirds into 3 new keys
		- Generate round keys for each of these 3 keys
		- Break original input into 8-byte blocks
		- Decrypt, encrypt, decrypt these blocks using keys 3, 2, and 1 respectively
		- Print output, repeat
	- Decrypt3
		- Break original key in thirds into 3 new keys
		- Generate round keys for each of these 3 keys
		- Break original input into 8-byte blocks
		- Encrypt, decrypt, encrypt these blocks using keys 1, 2, and 3 respectively
		- Print output, repeat

3. Known Bugs
	- None known

4. Deviation from the specs
	- None known
	
5. References
	- None needed

